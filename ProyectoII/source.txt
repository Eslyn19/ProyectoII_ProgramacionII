#include "raylib.h"
#include <string>
#include <fstream>
#include <ctime>
#include "usuario.h"

#define LOGO "WindowLogo.png"
#define FONDO "InitWindow.jpg"

struct TextBox {
    Rectangle bounds;
    std::string text;
    bool focused;
};

bool IsMouseOver(Rectangle rect) {
    return CheckCollisionPointRec(GetMousePosition(), rect);
}

int main() {
    const int screenWidth = 800;
    const int screenHeight = 500;

    InitWindow(screenWidth, screenHeight, "Guardar Usuario");
    Image icon = LoadImage(LOGO);
    SetWindowIcon(icon);
    UnloadImage(icon);
    Texture2D fondo = LoadTexture(FONDO);

    SetTargetFPS(60);

    TextBox box1 = { {50, 80, 300, 40}, "", false };
    TextBox box2 = { {50, 150, 300, 40}, "", false };
    Rectangle guardarBtn = { 50, 220, 120, 40 };

    bool guardado = false;
    float guardadoTimer = 0.0f;

    const int maxLength = 20;

    while (!WindowShouldClose()) {
        Vector2 mouse = GetMousePosition();

        // Cambiar focus con click
        if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {
            box1.focused = CheckCollisionPointRec(mouse, box1.bounds);
            box2.focused = CheckCollisionPointRec(mouse, box2.bounds);
        }

        // Entrada de texto
        TextBox* focusedBox = nullptr;
        if (box1.focused) focusedBox = &box1;
        else if (box2.focused) focusedBox = &box2;

        if (focusedBox != nullptr) {
            int key = GetCharPressed();
            while (key > 0) {
                if ((key >= 32 && key <= 125) && focusedBox->text.length() < maxLength) {
                    focusedBox->text += static_cast<char>(key);
                }
                key = GetCharPressed();
            }

            if (IsKeyPressed(KEY_BACKSPACE) && !focusedBox->text.empty()) {
                focusedBox->text.pop_back();
            }
        }

        // Validación para guardar
        bool puedeGuardar = !box1.text.empty() && !box2.text.empty() &&
            box1.text.length() > 2 && box2.text.length() > 2;

        // Guardar si clic en botón
        if (puedeGuardar && IsMouseButtonPressed(MOUSE_LEFT_BUTTON) && IsMouseOver(guardarBtn)) {
            Usuario user;
            user.setNombre(box1.text);
            user.setApellido(box2.text);
            user.setID("208380902");

            Json::Value jsonUser = user.toJson();
            std::ofstream file("usuarios.json", std::ios::app);
            if (file.is_open()) {
                Json::StreamWriterBuilder writer;
                std::unique_ptr<Json::StreamWriter> jsonWriter(writer.newStreamWriter());
                jsonWriter->write(jsonUser, &file);
                file << "\n";
                file.close();
            }
            // Limpiar campos
            box1.text.clear();
            box2.text.clear();
        }

        // Actualizar timer
        if (guardado) {
            guardadoTimer -= GetFrameTime();
            if (guardadoTimer <= 0.0f) {
                guardado = false;
            }
        }

        // Dibujo
        BeginDrawing();
        ClearBackground(RAYWHITE);
        DrawTexture(fondo, 0, 0, WHITE);

        DrawText("Nombre:", 50, 60, 20, DARKGRAY);
        DrawRectangleRec(box1.bounds, box1.focused ? SKYBLUE : LIGHTGRAY);
        DrawRectangleLinesEx(box1.bounds, 2, DARKGRAY);
        DrawText(box1.text.c_str(), (int)box1.bounds.x + 5, (int)box1.bounds.y + 10, 20, BLACK);

        DrawText("Apellido:", 50, 130, 20, DARKGRAY);
        DrawRectangleRec(box2.bounds, box2.focused ? SKYBLUE : LIGHTGRAY);
        DrawRectangleLinesEx(box2.bounds, 2, DARKGRAY);
        DrawText(box2.text.c_str(), (int)box2.bounds.x + 5, (int)box2.bounds.y + 10, 20, BLACK);

        Color btnColor = puedeGuardar ? GREEN : GRAY;
        DrawRectangleRec(guardarBtn, btnColor);
        DrawRectangleLinesEx(guardarBtn, 2, DARKGRAY);
        DrawText("Guardar", (int)guardarBtn.x + 15, (int)guardarBtn.y + 10, 20, RAYWHITE);

        if (guardado) {
            DrawText("Guardado exitosamente!", 200, 230, 20, DARKGREEN);
        }

        EndDrawing();
    }

   
    UnloadTexture(fondo);
    CloseWindow();

    return 0;
}
